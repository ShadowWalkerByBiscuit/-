###  这次的公众号目标是肥朝，主要是针对Redis的一次整理阅读。  

Redis的qps读是11w，写是8w。  

String 最大支持512M。  

zset 每个元素都会关联一个 double 类型的分数。redis 通过分数来为集合中的成员进行从小到大的排序。zset 的元素是唯一的，但是分数（score）却可以重复。  

Redis 事务不保证原子性。简单的说，多条命令中有个别失败的，整体还是会继续执行完成。  

Redis执行事务可以分成三个阶段，1-MULTI开启事物2-命令进入队列3-EXEC执行事务。  

Redis持久化分两种：  
1-RDB（fork一个子线程，同事内存会翻倍）   
2-AOF(Append only file)文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。所以这里就会有相应的同步策略（always会影响性能everysec表示每一秒，即使丢失也不会太多no就会丢失数据）。   

主从复制，是通过传输RDB文件给子服务器实现的。使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。   

Redis进行RDB的指令：   
1-Save阻塞进行，期间不处理其他指令，这里可以通过save配置触发的条件（save 900 1 表示900 秒内如果至少有 1 个 key 的值变化，则触发RDB）   
2-bgsave就是异步执行，也是fork一个子线程来完成任务，这里在fork的过程中也是会阻塞的，理论上时间很短，但是由于数据量过大也可能带来长时间的阻塞。   
3-saveCron就是通过定时任务的形式进行备份，具体过程是定时检查save配置的条件是否被满足，如果满足的话就通过bgsave来进行RDB。  

因为AOF是根据时间不断累加的，这样就会造成堆积，Redis提供了精简优化的rewrite方法，生成一份新的AOF文件，保证新旧两份文件对于Redis数据状态来说是一致的，但是新文件通常小得多（只要最后数据一致，多条命令最终状态，那么一条命令就可以替换掉。）AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或者写入操作，而是通过读取服务器当前的数据库状态来实现的。首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是 AOF 重写功能的实现原理。
